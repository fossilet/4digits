#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
    4digits - A guess-the-number game, aka Bulls and Cows
    Copyright (c) 2004-2007 Pan Yongzhi <http://pan.cdut.cn/4digits>

    4digits is a guess-the-number puzzle game. You are given eight times
    to guess a four-digit number. One digit is marked A if its value and
    position are both correct, and marked B if only its value is correct.
    You win the game when you get 4A0B. Good luck!

    4digits is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License as
    published by the Free Software Foundation; either version 2 of
    the License, or (at your option) any later version.

    4digits is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with 4digits; if not, write to the Free Software Foundation,
    Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
"""

import sys

try:
    import pygtk
    pygtk.require('2.0')
    import gtk
    import gtk.glade
except:
    print 'PyGTK is required to run 4digits.'
    print 'No PyGTK was found on your system.'
    sys.exit(1)

import os
import pwd
import random
import time
import webbrowser

gladefiles = [os.path.join(os.path.dirname(__file__), '4digits.glade'),
    os.path.normpath(os.path.join( # ??
    os.path.dirname(__file__), '../share/4digits/4digits.glade'))]
helpfile = os.path.normpath(os.path.join(
    os.path.dirname(__file__), '../share/doc/4digits/index.html'))
# FIXME won't work for windows
score_file = os.path.expanduser('~/.4digits/4digits.4digits.scores')

def _(arg):
    return arg

def load_glade(dialog = None):
        for gladefile in gladefiles:
            try:
                return gtk.glade.XML(gladefile, dialog) 
            except RuntimeError:
                pass #Just ignore the error, the next file will be tested
        #Still here?
        print "Gladefile not found! Checked pathes were:"
        print gladefiles
        sys.exit(2)
    
class fourDigits:
    """This is the main class"""
    def __init__(self):
        """GUI initialization"""
        self.wTree = load_glade()
        self.toolbar = self.wTree.get_widget('toolbar')
        self.view_toolbar = self.wTree.get_widget('view_toolbar')

        self.hint_table = self.wTree.get_widget('box_hints')
        self.hseparator2 = self.wTree.get_widget('hseparator2')
        self.view_hint_table = self.wTree.get_widget('view_hint_table')

        self.entry = self.wTree.get_widget('entry')
        self.entry.grab_focus()

        self.btOK = self.wTree.get_widget('btOK')
        self.btOK.set_sensitive(True)
        self.entry.set_sensitive(True)

        self.table = self.wTree.get_widget("table1")
        for widget in ('g0', 'g1', 'g2', 'g3', 'g4', 'g5', 'g6', 'g7',
                'r0', 'r1', 'r2', 'r3', 'r4', 'r5', 'r6', 'r7'):
            setattr(self, widget, self.wTree.get_widget(widget))
        self.info_label = self.wTree.get_widget('info_label')
        self.time_label = self.wTree.get_widget('time_label')
        
        self.score_view = self.wTree.get_widget('score_view')
	self.build_hint_grid()
        dic = {'on_window1_destroy': gtk.main_quit,
                'on_btQuit_clicked': gtk.main_quit,
                'on_mQuit_activate': gtk.main_quit,
                'on_btOK_clicked': self.on_entry_activate,
                'on_new_game': self.on_new_game,
                'on_view_toolbar_toggled': self.on_view_toolbar_toggled,
                'on_view_hint_table_toggled': self.on_view_hint_table_toggled,
                'on_entry_activate': self.on_entry_activate,
                'on_entry_changed': self.on_entry_changed,
                'on_mHelp_activate' : self.on_mHelp_activate,
                'on_mAbout_activate' : self.on_mAbout_activate,
                'on_score_menu_activate': self.on_score_menu_activate}
        self.wTree.signal_autoconnect(dic)
        # new game initialization
        self.game = newRound()

    def build_hint_grid(self):
    	box_hints = self.wTree.get_widget('box_hints')
    	self.cb_hint = []
	self.label_hint = []
        for name in (0, 40):
	    table = gtk.Table(rows=11, columns=6)
	    box_hints.pack_start(table)
	    for y in range(0, 10):
	    	label = gtk.CheckButton(str(y))
		label.set_active(True)
		table.attach(label, 0, 1, y+1, y+2)
		label.connect('toggled', self.change_row, y+name)
		self.label_hint.append(label)
	    for x in range(1, 5):
	    	label = gtk.Label(str(x))
		table.attach(label, x, x+1, 0, 1)
		for y in range(0,10):
		    checkbutton = gtk.CheckButton()
		    table.attach(checkbutton, x, x+1, y+1, y+2)
		    self.cb_hint.append(checkbutton)
	    if name == 0:
	    	box_hints.pack_start(gtk.VSeparator())

    def change_row(self, widget, row):
	enable = widget.get_active()
	for i in range(0,4):
	    self.cb_hint[10*i+row].set_sensitive(enable)

    def on_entry_activate(self, widget):
        """when input is accepted"""
        A, B = 0, 0
        number = ''
        # check input
        if self.game.guess < 8:
            number = self.entry.get_text()
            if number == '':
                self.error_process(_('Must input something.'))
                return False
            elif number[0] == '0':
                self.error_process(_('First digit cannot be zero.'))
                return False
            try:
                number = repr(int(number))
            except ValueError:
                self.error_process(_('Must input a number.'))
                return False
            if len(number) < 4:
                self.error_process(_('Must input four digits.'))
                return False
            elif len(set(number)) <4:
                self.error_process(_('Four digits must be unique.'))
                return False
            elif number in self.game.guesses:
                self.error_process(_("You've guessed it."))
                return False
            self.game.guesses.append(number)
            # process input
            for i in xrange(4):
                for j in xrange(4):
                    if self.game.answer[i] == int(number[j]):
                        if i == j:
                            A += 1
                        else:
                            B += 1
            guess_label = getattr(self, 'g' + repr(self.game.guess))
            result_label = getattr(self, 'r' + repr(self.game.guess))
            guess_label.set_text(number)
            result_label.set_text('%dA%dB' % (A, B))
            
            # win
            if A == 4:
                self.info_label.set_text(_('You win! :)'))
                self.get_time_taken_till_now()
                self.time_label.set_text(_('Used %.1f s.') % self.game.time_taken)
                self.btOK.set_sensitive(False)
                self.entry.set_sensitive(False)
                if self.is_high_score(self.game.time_taken):
                    new_score_rank = self.write_score(self.game.time_taken)
                    self.show_score(new_score_rank)
            # lose
            elif self.game.guess == 7:
                answer = ''
                for i in xrange(4):
                    answer += repr(self.game.answer[i])
                self.info_label.set_text(_('Haha, you lose. It is %s.') % answer)
                self.get_time_taken_till_now()
                self.time_label.set_text(_('Wasted %.1f s.') % self.game.time_taken)
                self.btOK.set_sensitive(False)
                self.entry.set_sensitive(False)
        self.game.guess += 1
        self.entry.grab_focus()

    def on_entry_changed(self, widget):
        self.info_label.set_text('')
        if self.game.on_entry_cb_first_called_in_this_round == True:
            self.time_label.set_text(_('Timer started...'))
            self.game.time_start = time.time()
            self.game.on_entry_cb_first_called_in_this_round = False
  
    def on_view_toolbar_toggled(self, widget):
        """Toggle toolbar visibility"""
        if self.view_toolbar.get_active():
            self.toolbar.show()
        else:
            self.toolbar.hide()

    def on_view_hint_table_toggled(self, widget):
        """Toggle hint table visibility"""
        if self.view_hint_table.get_active():
            self.hint_table.show_all()
            self.hseparator2.show()
        else:
            self.hint_table.hide_all()
            self.hseparator2.hide()

    def on_mHelp_activate(self, widget):
        webbrowser.open(helpfile)

    def on_mAbout_activate(self, widget):
        about = aboutDialog().dAbout
        about.run()
        about.destroy()
    
    def on_score_menu_activate(self, new_score_rank):
        sd = scoreDialog()
        dlg = sd.dScore
        sv = sd.score_view
        sv_selection = sv.get_selection()
        sv_selection.set_mode(gtk.SELECTION_NONE)
        column = gtk.TreeViewColumn('Name', gtk.CellRendererText(), text = 0)
        sv.append_column(column)
        column = gtk.TreeViewColumn('Score', gtk.CellRendererText(), text = 1)
        sv.append_column(column)
        column = gtk.TreeViewColumn('Date', gtk.CellRendererText(), text = 2)
        sv.append_column(column)
        dlg.scoreList = gtk.ListStore(str, str, str)
        sv.set_model(dlg.scoreList)

        scores = [line.split(' ', 6) for line in file(score_file, 'r')]

        for line in scores:
            score_tup = line[0], line[1], ' '.join(line[2:]).rstrip('\n')
            dlg.scoreList.append(score_tup)

        try:
            sv_selection.set_mode(gtk.SELECTION_SINGLE)
            sv_selection.select_path(new_score_rank)
        except:
            sv_selection.set_mode(gtk.SELECTION_NONE)

        dlg.run()
        dlg.destroy()

    def on_new_game(self, widget):
        """New game initialization"""
        self.game = newRound()
        self.btOK.set_sensitive(True)
        self.entry.set_sensitive(True)
        self.entry.grab_focus()
        # won't start the timer when you just start a new game
        self.game.on_entry_cb_first_called_in_this_round = False
        self.entry.set_text('')
        self.game.on_entry_cb_first_called_in_this_round = True
        self.info_label.set_text(_('Ready'))
        #self.info_label.set_text(_(str(self.game.answer)))
        self.time_label.set_text('')

        for i in xrange(8):
            getattr(self, 'g' + repr(i)).set_text('')
            getattr(self, 'r' + repr(i)).set_text('')
        
        for i in range(0, 80):
	    self.cb_hint[i].set_active(False)
	for i in range(0, 10):
	    self.label_hint[i].set_active(True)

    def error_process(self, msg):
        self.info_label.set_text(msg)
        self.entry.grab_focus()

    def get_time_taken_till_now(self):
        self.game.time_end = time.time()
        self.game.time_taken = self.game.time_end - self.game.time_start
        self.game.time_taken = round(self.game.time_taken, 1)

    def is_high_score(self, time_taken):
        scores = [line.split(' ', 6) for line in file(score_file, 'r')]
        if len(scores) < 10:
            return True
        scores = sorted(scores, key = lambda x: float(x[1][:-1]))
        if time_taken < float(scores[-1][1][:-1]):
            return True
        else:
            return False

    def write_score(self, time_taken):
        date = time.strftime("%a %b %d %H:%M:%S %Y"); 
        new_score = "%s %ss %s\n" % (
                # FIXME unix only
                # it's better to get the realname from pw_gecos field
                pwd.getpwuid(os.getuid())[0], time_taken, date)
                #os.getlogin(), time_taken, date)
        saved_scores = file(score_file, 'r').readlines()
        saved_scores.append(new_score)
        scores = [line.split(' ', 6) for line in saved_scores]
        scores = sorted(scores, key = lambda x: float(x[1][:-1]))
        scores = scores[:10]

        # find the index of the new score
        new_score = new_score.split(' ', 6)
        new_score_rank = scores.index(new_score)

        fp = open(score_file, 'w')
        for score in scores:
            fp.write(' '.join(score))
        fp.close()
        return new_score_rank

    def show_score(self, new_score_rank):
        self.on_score_menu_activate(new_score_rank)

class aboutDialog:
    """the about dialog"""
    def __init__(self):
        self.wTree = load_glade('dAbout') 
        self.dAbout = self.wTree.get_widget("dAbout")
        self.dAbout.set_name('4digits')
        self.dAbout.set_title(_('About 4digits'))
        gtk.about_dialog_set_url_hook(
                lambda about_dialog, url: webbrowser.open(url))
        self.dAbout.set_website('http://pan.cdut.cn/4digits')
        self.dAbout.set_website_label('http://pan.cdut.cn/4digits')

class scoreDialog:
    """the score dialog"""
    def __init__(self):
        self.wTree = load_glade('score_dlg')
        self.dScore = self.wTree.get_widget("score_dlg")
        self.score_view = self.wTree.get_widget('score_view')

class newRound:
    """Tihs class contains data in one round of the game"""
    def __init__(self):
        while True:
            self.answer = random.sample(range(10), 4)
            if self.answer[0] != 0:
                break
        if self.answer == 4619:
            print 'You are the luckiest guy on the planet!'
        self.answer = [7, 2, 0, 9]
        print self.answer
        self.guess = 0
        self.guesses = []
        self.time_start = 0
        self.time_end = 0
        self.time_taken = 0
        self.on_entry_cb_first_called_in_this_round = True

if __name__ == "__main__":
    fourdigits = fourDigits()
    gtk.main()
